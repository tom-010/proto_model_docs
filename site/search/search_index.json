{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This site contains the project documentation for the <code>calculator</code> project that is a toy module used in the Real Python tutorial Build Your Python Project Documentation With MkDocs. Its aim is to give you a framework to build your project documentation using Python, MkDocs, mkdocstrings, and the Material for MkDocs theme.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<p>The documentation follows the best practice for project documentation as described by Daniele Procida in the Di\u00e1taxis documentation framework and consists of four separate parts:</p> <ol> <li>Tutorials</li> <li>How-To Guides</li> <li>Reference</li> <li>Explanation</li> </ol> <p>Quickly find what you're looking for depending on your use case by looking at the different pages.</p>"},{"location":"#message-as-base-of-your-model","title":"Message as Base of your model","text":"<p>To define your model, create classes which extend this class. Then create class-level attributes where different FieldTypes are assigned, like StringField or Int32Field. You can mark all methods that you want to call from your client with the @rpc annotation (see the rpc-function in this file for details).</p> <p>Example:</p> <pre><code>class Employee(Message):\n    id = StringField(1)\n    firstName = StringField(2, default=lambda self: f'no name {self.age}')\n    age = Int32Field(3)\n    roles = StringField(4, repeated=True)\n    address = EmbeddedField(5, Address)\n    dresses = EmbeddedField(6, Dress, repeated=True)\n    createdAt = Int64Field(7, onCreate=currentTimestamp)\n    lastUpdatedAt = Int64Field(8, onUpdate=currentTimestamp)\n\n    @rpc\n    def summarizeModel(self) -&gt; str:\n        return f'{self.id} | {self.firstName} {self.age}, {self.roles}'\n\n    @rpc\n    def sayHello(self, name : Name) -&gt; str:\n        msg = self.messageBulider(name.firstName)\n        return msg\n</code></pre> Source code in <code>proto_model/pm.py</code> <pre><code>class Message:\n'''\n    To define your model, create classes which extend this class. Then\n    create class-level attributes where different FieldTypes are assigned,\n    like StringField or Int32Field.\n    You can mark all methods that you want to call from your client with\n    the @rpc annotation (see the rpc-function in this file for details).\n\n    Example:\n\n    ```python\n    class Employee(Message):\n        id = StringField(1)\n        firstName = StringField(2, default=lambda self: f'no name {self.age}')\n        age = Int32Field(3)\n        roles = StringField(4, repeated=True)\n        address = EmbeddedField(5, Address)\n        dresses = EmbeddedField(6, Dress, repeated=True)\n        createdAt = Int64Field(7, onCreate=currentTimestamp)\n        lastUpdatedAt = Int64Field(8, onUpdate=currentTimestamp)\n\n        @rpc\n        def summarizeModel(self) -&gt; str:\n            return f'{self.id} | {self.firstName} {self.age}, {self.roles}'\n\n        @rpc\n        def sayHello(self, name : Name) -&gt; str:\n            msg = self.messageBulider(name.firstName)\n            return msg\n    ```\n    '''\n\n    def __init__(self, *arg, **kwargs):\n'''\n        Prepares the kwargs for protobuf, creates a probouf message and sets the\n        data passed via kwargs to it. Message is a wrapper around a protobuf message\n        using __getattribute__ and __setattribute__ and the protobuf-message is\n        responsible of holding the data, while this class can add \"extension-methods\"\n        to it.\n        Beside that this constructor does house-keeping like setting the names of its\n        fields and sets up lazy-loading.\n        '''\n\n        # Set the names to the fields\n        #  ===========================\n        # We define the fields like: `address = EmbeddedField(5, Address)`\n        # where the EmbeddedField is a field. But now, the field-name is external\n        # to the constructor call - on the left hand side of the equal sign (address)\n        # Thus we have to set it here from external, where we have both access to the\n        # field and the name of the message-field-attribute\n        # self.__class__ -- the same as self.__class__, but go around\n        # __getattribute__\n        cls = object.__getattribute__(self, '__class__')\n        for fieldName in [f for f in dir(cls) if not f.startswith('_')]:\n            field = _getattr_or_none(cls, fieldName)\n            if not field:\n                continue\n            if isinstance(field, Field):\n                field.name = fieldName\n\n        # Replace ReferenceField-values with ID-strings pointing to the references object\n        #  ===============================================================================\n        # In the end of the day, we want to construct the kwargs and pass it to the\n        # proto-model which we wrap. This proto model contains all the data and we\n        # wrap it via the __getattribute__-method.\n        # But when there is a ReferenceField, we don't want to give the real reference\n        # to the protobuf-model, but only the id. Protobuf is always serializable and\n        # in this world, references are IDs to other messages, not python-object-refs.\n        # Therefore, we loop over the kwargs, get the field of this message to get the\n        # type of it. Now we can check if it is a Reference field and if so, extract\n        # the ID and replace the entry in the kwargs with it.\n        # The same idea, but within a list applies when the field is also\n        # repeated.\n        referenceIdFields = {}\n        for name in kwargs.keys():\n            field = _getattr_or_none(self, name)\n            if not field:\n                continue\n            if isinstance(field, ReferenceField):\n                if field.repeated:\n                    referenceIdFields[field.name] = [\n                        o.id for o in kwargs[name]]\n                else:\n                    referenceIdFields[field.name] = kwargs[name].id\n        # because referenceIdFields come second, they override\n        kwargs = {**kwargs, **referenceIdFields}\n\n        # Initialized the wrapped Proto-Message\n        #  =====================================\n        # Create a protobuf-instance as data-container and initalize it with the data we got\n        # via kwargs. In this way to user can use the Message class as if it would be a\n        # proto-message and we can extend our functionality around it.\n        name = cls.__name__\n        proto = name_to_grpc_message_or_method(name)()\n        proto = ParseDict(kwargs, proto, ignore_unknown_fields=True)\n        # We use the Message class to wrap the proto-message-class which holds the actual data.\n        # thus we set the data into the proto-attribute and whenever someone asks us for data\n        # we take it from there\n        # required to do it with __setattr__, as __setattr__ already needs\n        # self.proto\n        super().__setattr__('proto', proto)\n\n        # Initalize Lazy Loading\n        #  ======================\n        # self._loaded indicates, if the data is loaded from the database. We often only transfer\n        # the ID of the model over the wire. In this case, the have to take this ID and ask the\n        # database for the data belongin to this ID and set it to the fields. But we want to do this\n        # lazy. Thus we initialize the class with only the ID, set the _loaded=False (which is done\n        # by the web layer) and as soon as the DB set the data, it sets it back\n        # to _loaded=False\n        self._loaded = True  # per default, the ORM- or Web-Layer should set it to False, if not\n\n    # TODO: isn't __getattr__ more suitable?\n\n    def __getattribute__(self, name):\n'''\n        As Message is in the runtime only a wrapper around protobuf, return the data from the\n        self.proto\n        But there is additional functionality we want like lazy loading or ReferenceFields which\n        have to be resolved on the fly\n        '''\n\n        def attr(n: str) -&gt; Any:\n'''\n            A little helper to access fields of the Message-Object and not run into\n            recursion as self.n would call __getattribute__(self, n) and so on.\n            '''\n            return object.__getattribute__(self, n)\n\n        def take_value_from_proto_and_maybe_lazy_load():\n            # do not lazy load, if\n            #   - the requested attribute is id, as is is has to be already present, thus no need for lazy loading\n            #   - we not already have done so. The DB- and Web-Layer set _loaded to false when creating an instance\n            #   - the ID is not set, lazy loading converts the ID to the data\n            if not name == 'id' and not attr('_loaded') and attr('id'):\n                db_result = self.db.query(\n                    attr('proto').__class__, {\n                        '_id': attr('_id')})\n                if db_result:\n                    loaded_doc_from_db = db_result[0]\n                    setattr(self, 'proto', loaded_doc_from_db)\n                    # when using only setattr, the getattr outide the if gets still\n                    # the old message. It works, when doing it a second time, but this\n                    # is too hacky. I don't know why. If we return the value of the\n                    # freshly loaded object it works on the first try.\n                    # DO NOT DELETE !! read the comment above!\n                    return getattr(loaded_doc_from_db, name)\n\n            # lazy loading not required / has no effect. Return the value already in the proto-message\n            # This should be the normal case\n            return getattr(proto, name)\n\n        # normal case, if values are present and lazy-loading\n        #  ===================================================\n        # If the proto-message has the given field we can return it\n        # directoly or load it on the fly\n        proto = attr('proto')\n        if hasattr(proto, name):\n            return take_value_from_proto_and_maybe_lazy_load()\n\n        # ReferenceFields (Foreign Keys) Lazy Loading\n        #  ==============================================\n        # If the proto-message does not have the requested field, check if it\n        # is an reference field.\n        # References of Reference-Fields only contain the ID to the referenced\n        # objects, thus are always lazy. This means, that we have to load them\n        # on the fly.\n        # More complexity is added because we alsow allow repeated ReferenceFields\n        # to allow unidirectoral Many-To-Many definition\n        attribute_value = attr(name)\n        if isinstance(attribute_value, ReferenceField):  # lazy load first!\n\n            if attribute_value.repeated:\n                foreign_objects_ids = list(\n                    getattr(attr('proto'), attribute_value.name))\n                db_res = self.db.query(\n                    attribute_value.otherClass, {\n                        '_id': {\n                            '$in': foreign_objects_ids}})\n                if not db_res:\n                    return []\n                setattr(self, name, db_res)\n                return db_res\n\n            else:  # not repeatet\n                foreign_object_id = getattr(\n                    attr('proto'), attribute_value.name)\n                if foreign_object_id:\n                    db_res = self.db.query(\n                        attribute_value.otherClass, {\n                            '_id': foreign_object_id})\n                    if not db_res:\n                        return None  # Or create an empty instance ??\n                    attribute_value = db_res[0]\n                    # cache for the next time (getattr will pick it up)\n                    setattr(self, name, attribute_value)\n                    return attribute_value\n\n                # in this case, there is no id assigned yet. Initalize an empty container, so that the user still\n                # can set attributes this is only relevant, if not repeated. In the latter case it would just be\n                # an empty list and we can expect that the user adds new\n                # instances to the list.\n                else:\n                    attribute_value = attribute_value.otherClass()\n                    setattr(self, name, attribute_value)\n                    return attribute_value\n\n        # Return attribute of extended class\n        #  ==================================\n        # If it not a reference-field and not part of the proto-message, it has to be defined\n        # in the extended Message-Class by the user, e.g. by self.abc = 'value'\n        # In this case, we can just return the value, we obtained via attr(name) which is like\n        # calling self.`name`\n\n        return attribute_value\n\n    def __setattr__(self, name, value):\n'''\n        If the proto-message has the attribute, set the value there\n        else set it to this class.\n        '''\n        if hasattr(self.proto, name):\n            return setattr(self.proto, name, value)\n        return super().__setattr__(name, value)\n\n    def __str__(self):\n        return str(self.proto)\n\n    def __eq__(self, other):\n        return isinstance(self, type(other)) and self.proto == other.proto\n\n    def set_defaults(self, creating=False):\n'''\n        Called by the database-layer on store (either on create or update)\n        Gives a hook to set the right defaults at the right time.\n        Itererates through the fields and calls their set_defaults. Thus\n        it distributes the work down. See the subclasses of Field for\n        details.\n        '''\n        c = object.__getattribute__(self, '__class__')\n        for fieldName in [f for f in dir(c) if not f.startswith('_')]:\n            field = object.__getattribute__(self, fieldName)\n            if isinstance(field, Field):\n                field.name = fieldName\n                field.set_defaults(self, creating)\n\n    @property\n    def db(self):\n'''\n        When the user defines the model, this class is extended. Within the\n        methods, he wants to use self.db -&gt; This becomes possible with this.\n        It is set by the server, which connects to the correct database for\n        every request.\n\n        Also used for lazy-loading resolve in the __getattribute__ part.\n        '''\n        from .provide import use_provided\n        from proto_model.db import DB_KEY\n        return use_provided(DB_KEY)\n</code></pre>"},{"location":"#proto_model.pm.Message.db","title":"<code>db</code>  <code>property</code>","text":"<p>When the user defines the model, this class is extended. Within the methods, he wants to use self.db -&gt; This becomes possible with this. It is set by the server, which connects to the correct database for every request.</p> <p>Also used for lazy-loading resolve in the getattribute part.</p>"},{"location":"#proto_model.pm.Message.__getattribute__","title":"<code>__getattribute__(name)</code>","text":"<p>As Message is in the runtime only a wrapper around protobuf, return the data from the self.proto But there is additional functionality we want like lazy loading or ReferenceFields which have to be resolved on the fly</p> Source code in <code>proto_model/pm.py</code> <pre><code>def __getattribute__(self, name):\n'''\n    As Message is in the runtime only a wrapper around protobuf, return the data from the\n    self.proto\n    But there is additional functionality we want like lazy loading or ReferenceFields which\n    have to be resolved on the fly\n    '''\n\n    def attr(n: str) -&gt; Any:\n'''\n        A little helper to access fields of the Message-Object and not run into\n        recursion as self.n would call __getattribute__(self, n) and so on.\n        '''\n        return object.__getattribute__(self, n)\n\n    def take_value_from_proto_and_maybe_lazy_load():\n        # do not lazy load, if\n        #   - the requested attribute is id, as is is has to be already present, thus no need for lazy loading\n        #   - we not already have done so. The DB- and Web-Layer set _loaded to false when creating an instance\n        #   - the ID is not set, lazy loading converts the ID to the data\n        if not name == 'id' and not attr('_loaded') and attr('id'):\n            db_result = self.db.query(\n                attr('proto').__class__, {\n                    '_id': attr('_id')})\n            if db_result:\n                loaded_doc_from_db = db_result[0]\n                setattr(self, 'proto', loaded_doc_from_db)\n                # when using only setattr, the getattr outide the if gets still\n                # the old message. It works, when doing it a second time, but this\n                # is too hacky. I don't know why. If we return the value of the\n                # freshly loaded object it works on the first try.\n                # DO NOT DELETE !! read the comment above!\n                return getattr(loaded_doc_from_db, name)\n\n        # lazy loading not required / has no effect. Return the value already in the proto-message\n        # This should be the normal case\n        return getattr(proto, name)\n\n    # normal case, if values are present and lazy-loading\n    #  ===================================================\n    # If the proto-message has the given field we can return it\n    # directoly or load it on the fly\n    proto = attr('proto')\n    if hasattr(proto, name):\n        return take_value_from_proto_and_maybe_lazy_load()\n\n    # ReferenceFields (Foreign Keys) Lazy Loading\n    #  ==============================================\n    # If the proto-message does not have the requested field, check if it\n    # is an reference field.\n    # References of Reference-Fields only contain the ID to the referenced\n    # objects, thus are always lazy. This means, that we have to load them\n    # on the fly.\n    # More complexity is added because we alsow allow repeated ReferenceFields\n    # to allow unidirectoral Many-To-Many definition\n    attribute_value = attr(name)\n    if isinstance(attribute_value, ReferenceField):  # lazy load first!\n\n        if attribute_value.repeated:\n            foreign_objects_ids = list(\n                getattr(attr('proto'), attribute_value.name))\n            db_res = self.db.query(\n                attribute_value.otherClass, {\n                    '_id': {\n                        '$in': foreign_objects_ids}})\n            if not db_res:\n                return []\n            setattr(self, name, db_res)\n            return db_res\n\n        else:  # not repeatet\n            foreign_object_id = getattr(\n                attr('proto'), attribute_value.name)\n            if foreign_object_id:\n                db_res = self.db.query(\n                    attribute_value.otherClass, {\n                        '_id': foreign_object_id})\n                if not db_res:\n                    return None  # Or create an empty instance ??\n                attribute_value = db_res[0]\n                # cache for the next time (getattr will pick it up)\n                setattr(self, name, attribute_value)\n                return attribute_value\n\n            # in this case, there is no id assigned yet. Initalize an empty container, so that the user still\n            # can set attributes this is only relevant, if not repeated. In the latter case it would just be\n            # an empty list and we can expect that the user adds new\n            # instances to the list.\n            else:\n                attribute_value = attribute_value.otherClass()\n                setattr(self, name, attribute_value)\n                return attribute_value\n\n    # Return attribute of extended class\n    #  ==================================\n    # If it not a reference-field and not part of the proto-message, it has to be defined\n    # in the extended Message-Class by the user, e.g. by self.abc = 'value'\n    # In this case, we can just return the value, we obtained via attr(name) which is like\n    # calling self.`name`\n\n    return attribute_value\n</code></pre>"},{"location":"#proto_model.pm.Message.__init__","title":"<code>__init__(*arg, **kwargs)</code>","text":"<p>Prepares the kwargs for protobuf, creates a probouf message and sets the data passed via kwargs to it. Message is a wrapper around a protobuf message using getattribute and setattribute and the protobuf-message is responsible of holding the data, while this class can add \"extension-methods\" to it. Beside that this constructor does house-keeping like setting the names of its fields and sets up lazy-loading.</p> Source code in <code>proto_model/pm.py</code> <pre><code>def __init__(self, *arg, **kwargs):\n'''\n    Prepares the kwargs for protobuf, creates a probouf message and sets the\n    data passed via kwargs to it. Message is a wrapper around a protobuf message\n    using __getattribute__ and __setattribute__ and the protobuf-message is\n    responsible of holding the data, while this class can add \"extension-methods\"\n    to it.\n    Beside that this constructor does house-keeping like setting the names of its\n    fields and sets up lazy-loading.\n    '''\n\n    # Set the names to the fields\n    #  ===========================\n    # We define the fields like: `address = EmbeddedField(5, Address)`\n    # where the EmbeddedField is a field. But now, the field-name is external\n    # to the constructor call - on the left hand side of the equal sign (address)\n    # Thus we have to set it here from external, where we have both access to the\n    # field and the name of the message-field-attribute\n    # self.__class__ -- the same as self.__class__, but go around\n    # __getattribute__\n    cls = object.__getattribute__(self, '__class__')\n    for fieldName in [f for f in dir(cls) if not f.startswith('_')]:\n        field = _getattr_or_none(cls, fieldName)\n        if not field:\n            continue\n        if isinstance(field, Field):\n            field.name = fieldName\n\n    # Replace ReferenceField-values with ID-strings pointing to the references object\n    #  ===============================================================================\n    # In the end of the day, we want to construct the kwargs and pass it to the\n    # proto-model which we wrap. This proto model contains all the data and we\n    # wrap it via the __getattribute__-method.\n    # But when there is a ReferenceField, we don't want to give the real reference\n    # to the protobuf-model, but only the id. Protobuf is always serializable and\n    # in this world, references are IDs to other messages, not python-object-refs.\n    # Therefore, we loop over the kwargs, get the field of this message to get the\n    # type of it. Now we can check if it is a Reference field and if so, extract\n    # the ID and replace the entry in the kwargs with it.\n    # The same idea, but within a list applies when the field is also\n    # repeated.\n    referenceIdFields = {}\n    for name in kwargs.keys():\n        field = _getattr_or_none(self, name)\n        if not field:\n            continue\n        if isinstance(field, ReferenceField):\n            if field.repeated:\n                referenceIdFields[field.name] = [\n                    o.id for o in kwargs[name]]\n            else:\n                referenceIdFields[field.name] = kwargs[name].id\n    # because referenceIdFields come second, they override\n    kwargs = {**kwargs, **referenceIdFields}\n\n    # Initialized the wrapped Proto-Message\n    #  =====================================\n    # Create a protobuf-instance as data-container and initalize it with the data we got\n    # via kwargs. In this way to user can use the Message class as if it would be a\n    # proto-message and we can extend our functionality around it.\n    name = cls.__name__\n    proto = name_to_grpc_message_or_method(name)()\n    proto = ParseDict(kwargs, proto, ignore_unknown_fields=True)\n    # We use the Message class to wrap the proto-message-class which holds the actual data.\n    # thus we set the data into the proto-attribute and whenever someone asks us for data\n    # we take it from there\n    # required to do it with __setattr__, as __setattr__ already needs\n    # self.proto\n    super().__setattr__('proto', proto)\n\n    # Initalize Lazy Loading\n    #  ======================\n    # self._loaded indicates, if the data is loaded from the database. We often only transfer\n    # the ID of the model over the wire. In this case, the have to take this ID and ask the\n    # database for the data belongin to this ID and set it to the fields. But we want to do this\n    # lazy. Thus we initialize the class with only the ID, set the _loaded=False (which is done\n    # by the web layer) and as soon as the DB set the data, it sets it back\n    # to _loaded=False\n    self._loaded = True  # per default, the ORM- or Web-Layer should set it to False, if not\n</code></pre>"},{"location":"#proto_model.pm.Message.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"<p>If the proto-message has the attribute, set the value there else set it to this class.</p> Source code in <code>proto_model/pm.py</code> <pre><code>def __setattr__(self, name, value):\n'''\n    If the proto-message has the attribute, set the value there\n    else set it to this class.\n    '''\n    if hasattr(self.proto, name):\n        return setattr(self.proto, name, value)\n    return super().__setattr__(name, value)\n</code></pre>"},{"location":"#proto_model.pm.Message.set_defaults","title":"<code>set_defaults(creating=False)</code>","text":"<p>Called by the database-layer on store (either on create or update) Gives a hook to set the right defaults at the right time. Itererates through the fields and calls their set_defaults. Thus it distributes the work down. See the subclasses of Field for details.</p> Source code in <code>proto_model/pm.py</code> <pre><code>def set_defaults(self, creating=False):\n'''\n    Called by the database-layer on store (either on create or update)\n    Gives a hook to set the right defaults at the right time.\n    Itererates through the fields and calls their set_defaults. Thus\n    it distributes the work down. See the subclasses of Field for\n    details.\n    '''\n    c = object.__getattribute__(self, '__class__')\n    for fieldName in [f for f in dir(c) if not f.startswith('_')]:\n        field = object.__getattribute__(self, fieldName)\n        if isinstance(field, Field):\n            field.name = fieldName\n            field.set_defaults(self, creating)\n</code></pre>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>I want to thank my house plants for providing me with a negligible amount of oxygen each day. Also, I want to thank the sun for providing more than half of their nourishment free of charge.</p>"},{"location":"explanation/","title":"Explanation","text":"<p>This part of the project documentation focuses on an understanding-oriented approach. You'll get a chance to read about the background of the project, as well as reasoning about how it was implemented.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Give context and background on your library</li> <li>Explain why you created it</li> <li>Provide multiple examples and approaches of how     to work with it</li> <li>Help the reader make connections</li> <li>Avoid writing instructions or technical descriptions     here</li> </ul>"},{"location":"how-to-guides/","title":"How-To Guides","text":"<p>This part of the project documentation focuses on a problem-oriented approach. You'll tackle common tasks that you might have, with the help of the code provided in this project.</p>"},{"location":"how-to-guides/#how-to-add-two-numbers","title":"How To Add Two Numbers?","text":"<p>You have two numbers and you need to add them together. You're in luck! The <code>calculator</code> package can help you get this done.</p> <p>Download the code from this GitHub repository and place the <code>calculator/</code> folder in the same directory as your Python script:</p> <pre><code>your_project/\n\u2502\n\u251c\u2500\u2500 calculator/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 calculations.py\n\u2502\n\u2514\u2500\u2500 your_script.py\n</code></pre> <p>Inside of <code>your_script.py</code> you can now import the <code>add()</code> function from the <code>calculator.calculations</code> module:</p> <pre><code># your_script.py\nfrom calculator.calculations import add\n</code></pre> <p>After you've imported the function, you can use it to add any two numbers that you need to add:</p> <pre><code># your_script.py\nfrom calculator.calculations import add\n\nprint(add(20, 22))  # OUTPUT: 42.0\n</code></pre> <p>You're now able to add any two numbers, and you'll always get a <code>float</code> as a result.</p>"},{"location":"reference/","title":"Reference","text":"<p>This part of the project documentation focuses on an information-oriented approach. Use it as a reference for the technical implementation of the <code>calculator</code> project code.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>This part of the project documentation focuses on a learning-oriented approach. You'll learn how to get started with the code in this project.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Help newcomers with getting started</li> <li>Teach readers about your library by making them     write code</li> <li>Inspire confidence through examples that work for     everyone, repeatably</li> <li>Give readers an immediate sense of achievement</li> <li>Show concrete examples, no abstractions</li> <li>Provide the minimum necessary explanation</li> <li>Avoid any distractions</li> </ul>"}]}